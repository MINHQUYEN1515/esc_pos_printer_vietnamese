import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:zpos/core/utils/string_utils.dart';
import 'package:zpos/features/settings/data/services/printer_service.dart';
import 'package:zpos/features/settings/domain/entities/printer_config.dart';

class LabelPrinterService {
  /// Loads all configured label printers from SharedPreferences
  static Future<List<PrinterConfig>> loadPrinters() async {
    return _loadPrinters();
  }

  /// Generates TSPL commands for printing a label - exposed for direct access
  static List<int> generateLabelData(
      String title, String content, String? additionalInfo) {
    return _generateLabelData(title, content, additionalInfo);
  }

  /// Prints a label to all available label printers
  static Future<void> printLabel(
    BuildContext context, {
    required String title,
    required String content,
    String? additionalInfo,
  }) async {
    // Load all label printers
    final printers = await _loadPrinters();

    if (printers.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text(
              'Không tìm thấy máy in nhãn nào. Vui lòng thiết lập máy in trong cài đặt.'),
          backgroundColor: Colors.orange,
        ),
      );
      return;
    }

    // Show loading dialog
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => const AlertDialog(
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            CircularProgressIndicator(),
            SizedBox(height: 16),
            Text('Đang in nhãn...'),
          ],
        ),
      ),
    );

    try {
      // Generate label data
      final List<int> bytes =
          _generateLabelData(title, content, additionalInfo);

      // Print to all label printers
      List<String> successPrinters = [];
      List<String> failedPrinters = [];

      for (var printer in printers) {
        try {
          if (printer.connectionMethod == 'LAN') {
            final String ipAddress = printer.settings['ipAddress'] as String;
            final int port = int.parse(printer.settings['port'] as String);

            await PrinterService.sendToPrinter(ipAddress, port, bytes);
            successPrinters.add(_getPrinterAddress(printer));
          } else if (printer.connectionMethod == 'USB') {
            // For USB printers
            if (printer.settings['vendorId'] != null &&
                printer.settings['productId'] != null) {
              final vendorId =
                  int.parse(printer.settings['vendorId'].toString());
              final productId =
                  int.parse(printer.settings['productId'].toString());
              // Connect to printer
              final connected =
                  await PrinterService.connectUsbPrinter(vendorId, productId);

              if (!connected) {
                throw Exception('Cannot connect to USB printer');
              }

              // Send data to printer
              final success = await PrinterService.sendToUsbPrinter(bytes);

              if (!success) {
                throw Exception('Failed to send data to USB printer');
              }

              successPrinters.add(_getPrinterAddress(printer));
            } else {
              failedPrinters.add(
                  '${_getPrinterAddress(printer)} (Missing USB device information)');
            }
          } else {
            // Skip non-supported printers for now
            failedPrinters.add(
                '${_getPrinterAddress(printer)} (${printer.connectionMethod} không được hỗ trợ)');
          }
        } catch (e) {
          print('Error printing to ${_getPrinterAddress(printer)}: $e');
          failedPrinters.add(_getPrinterAddress(printer));
        }
      }

      // Close loading dialog
      if (context.mounted && Navigator.of(context).canPop()) {
        Navigator.of(context).pop();
      }

      // Show success/failure message
      if (context.mounted) {
        if (successPrinters.isNotEmpty) {
          String message =
              'Đã in thành công đến ${successPrinters.length} máy in nhãn';
          if (failedPrinters.isNotEmpty) {
            message += '. ${failedPrinters.length} máy in thất bại.';
          }

          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(message),
              backgroundColor: Colors.green,
              duration: const Duration(seconds: 3),
            ),
          );
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Không thể in đến bất kỳ máy in nhãn nào'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    } catch (e) {
      print('Error in print process: $e');
      // Close loading dialog
      if (context.mounted && Navigator.of(context).canPop()) {
        Navigator.of(context).pop();
      }

      // Show error message
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Lỗi khi in nhãn: ${e.toString()}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  /// Loads all configured label printers from SharedPreferences
  static Future<List<PrinterConfig>> _loadPrinters() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final String? printersJson = prefs.getString('CACHED_PRINTERS');

      if (printersJson == null) {
        return [];
      }

      final List<dynamic> decodedList = json.decode(printersJson);
      return decodedList
          .map((item) => PrinterConfig.fromJson(item))
          .where((printer) => printer.printerType == 'LABEL')
          .toList();
    } catch (e) {
      print('Error loading printers: $e');
      return [];
    }
  }

  /// Gets a human-readable address for a printer
  static String _getPrinterAddress(PrinterConfig printer) {
    if (printer.connectionMethod == 'LAN') {
      return '${printer.settings['ipAddress']}:${printer.settings['port']}';
    } else if (printer.connectionMethod == 'BLUETOOTH' ||
        printer.connectionMethod == 'USB') {
      return printer.settings['deviceName'] ?? 'Unknown device';
    }
    return 'Unknown';
  }

  /// Generates TSPL commands for printing a label
  static List<int> _generateLabelData(
      String title, String content, String? additionalInfo) {
    // Remove Vietnamese accents for better compatibility
    final cleanTitle = StringUtils.removeAccents(title);
    final cleanContent = StringUtils.removeAccents(content);
    final cleanAdditionalInfo = additionalInfo != null
        ? StringUtils.removeAccents(additionalInfo)
        : null;

    // Get current date/time in the format shown in the image
    final now = DateTime.now();
    final formattedDate =
        "${now.day.toString().padLeft(2, '0')}-${now.month.toString().padLeft(2, '0')}-${now.year} ${now.hour.toString().padLeft(2, '0')}:${now.minute.toString().padLeft(2, '0')}";

    // TSPL commands for XPrinter label printers - match the exact layout in the image
    String tsplCommand = '''
SIZE 50 mm, 30 mm
GAP 2 mm, 0 mm
DENSITY 8
DIRECTION 1
CLS
TEXT 10,10,"2",0,1,1,"$cleanTitle"
BAR 0,30,240,2
TEXT 10,40,"2",0,1,1,"$cleanContent"
''';

    // Add additional info if provided (bullet points)
    int yPosition = 60;
    if (cleanAdditionalInfo != null) {
      // Split by newline to handle each bullet point separately
      final lines = cleanAdditionalInfo.split('\n');
      for (var line in lines) {
        tsplCommand += 'TEXT 10,$yPosition,"2",0,1,1,"$line"\n';
        yPosition += 20; // Increment Y position for each line
      }
    }

    // Add date/time at the bottom
    tsplCommand += 'BAR 0,${yPosition + 10},240,2\n'; // Bottom separator line
    tsplCommand += 'TEXT 10,${yPosition + 20},"2",0,1,1,"$formattedDate"\n';

    // Print command
    tsplCommand += 'PRINT 1,1\n';

    // Convert TSPL commands to bytes
    return utf8.encode(tsplCommand);
  }
}
